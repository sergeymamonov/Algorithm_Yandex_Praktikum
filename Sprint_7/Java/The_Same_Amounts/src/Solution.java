// 53587210
//
// Принцип работы алгоритма:
//      Алгоритм основан на двумерное динамическом программировании, в котором промежуточные результаты сохраняются в
//      матрице с размерами sum / 2 + 1 на N + 1, где sum - сумма всех элементов входного массива, N - количество элементов
//      во входном массиве.
//      В матрице dp будет храниться логический тип данных, который говорит, равна ли сумма текущего подмножества массива
//      текущему значению номера строки матрицы, которое находится в интервале от 1 до полусуммы всех элементов.
//      Базовым случаем, когда входной массив пуст, будет значение истины в ячейке dp[0][0].
//      Переход динамики: в каждую клетку матрицы можно перейти из:
//          - ячейки слева от текущей ячейки, dp[i][j - 1]
//          - ячейки из набора ячеек выше текущей и левее на одну клетку от текущей, dp[i - x][j - 1].
//      Формула перехода: значение в текущей ячейки верно, если верно значение в любой из клеток откуда сделан переход,
//      то есть dp[i][j] истинно, если истинно dp[i][j - 1] или истинно любая из ячеек dp[i][j - 1], при условии,
//      что текущее значение номера строки больше значения крайнего элемента в уже исследованном подмножестве
//      элементов, то есть (i >= arr[j - 1]).
//      Порядок вычислений в матрице: вычисления происходят слева направо, сверху вниз.
//      Ответ будет располагаться в правой нижней ячейки матрицы dp.
//
// Обоснование корректности:
//      Алгоритм корректен, так как на промежутке от 1 до полусуммы всех элементов входного массива происходит определение
//      равна ли сумма текущего подмножества массива текущему значению номера строки матрицы.
//
// Временная сложность:
//      Временная сложность будет складываться из:
//          - итерации по каждому целому числу от 1 до полусуммы всех элементов входного массива, O(sum/2), где sum -
//              сумма элементов входного массива.
//          - итерации по всем элементам входного массива, 0(N), где N - количество элементов во входном массиве,
//          - сравнения ячеек, O(1).
//      В итоге суммарная временная сложность O(sum/2 * N).
//
// Пространственная сложность:
//      Пространственная сложность состоит из хранения матрицы с размерами sum / 2 + 1 на N + 1, O(sum/2 * N)


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int numbersQuantity = Integer.parseInt(bufferedReader.readLine());
        int[] numbers = new int[numbersQuantity];
        StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());

        for (int i = 0; i < numbersQuantity; i++) {
            numbers[i] = Integer.parseInt(stringTokenizer.nextToken());
        }

        System.out.println(canPartition(numbers) ? "True" : "False");
    }


    static boolean canPartition(int arr[]) {
        int n = arr.length;
        int sum = 0;
        int i, j;

        for (i = 0; i < n; i++)
            sum += arr[i];

        if (sum % 2 != 0)
            return false;

        boolean dp[][] = new boolean[sum / 2 + 1][n + 1];

        for (i = 0; i <= n; i++)
            dp[0][i] = true;

        for (i = 1; i <= sum / 2; i++)
            dp[i][0] = false;

        for (i = 1; i <= sum / 2; i++) {
            for (j = 1; j <= n; j++) {
                dp[i][j] = dp[i][j - 1];
                if (i >= arr[j - 1])
                    dp[i][j]
                            = dp[i][j]
                            || dp[i - arr[j - 1]][j - 1];
            }
        }

        return dp[sum / 2][n];
    }
}
