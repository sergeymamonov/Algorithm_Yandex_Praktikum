// 53582709
//
// Принцип работы алгоритма:
//      Алгоритм основан на двумерное динамическом программировании, в котором промежуточные результаты сохраняются в
//      матрице с размерами l1 x l2, где l1 - длина первой строки, l2 -длина второй строки.
//      В матрице будут храниться редакционные расстояния (то есть количество символов, которые нужно изменить, чтобы
//      строка 1 стала идентичной строке 2.
//      Базовым случаем, когда длины первой и второй строк будут равны 0, то редакционное расстояние также будет равно 0.
//      При длине первой строки 0, первая строка в матрице будет строка последовательных числе, длиной,
//      равной длине второй строки.
//      Переходом динамики будет определение минимального значения из:
//          - значения ячейки слева от текущей + 1, dp[i][j - 1] + 1;
//          - значения ячейки выше от текущей + 1, dp[i - 1][j] + 1;
//          - значения ячейки выше и слева от текущей, dp[i - 1][j - 1] + 1 если буквы на текущей позиции в первой и второй
//          строках различны, + 0 - в обратном случае.
//      Порядок вычислений в матрице: матрица будет заполняться сверху вниз, слева направо.
//      Ответом будет нижний правый элемент матрицы.
//      С целью сокращения используемой памяти для сохранения результатов вычисления используются два массива.
//
// Обоснование корректности:
//      Алгоритм корректен, так как происходит сравнение каждого префикса одной строки с префиксом другой строки.
//      В качестве ответа выдается минимальное редакционное расстояние при сравнении полностью двух строк.
//
// Временная сложность:
//      Временная сложность будет складываться из:
//          - итерации по каждому символу 1 строки, O(l1), где l1 - длина первой строки,
//          - итерации по каждому символу 2 строки, O(l2), где l2 - длина второй строки,
//          - определения минимума из трех величин, O(1).
//      Итоговая временная сложность будет составлять O(l1 * l2).
//
// Пространственная сложность:
//      С учетом примененной оптимизации пространственная сложность складывается из:
//          - строки матрицы, равной длине второй строки плюс единица, так как отсчет в матрице начинается с единицы.
//          - еще одной строки матрицы такой же длины.
//
//      Итоговая пространственная сложность будет O(2 * (l2 + 1)), с учетом правил нотаций O большое, равносильно O(l2).


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String str1 = bufferedReader.readLine();
        String str2 = bufferedReader.readLine();

        System.out.println(levensteinDistance(str1, str2));
    }

    public static int levensteinDistance(String str1, String str2) {
        int[] dp_prev = new int[str2.length() + 1];
        int[] dp = new int[str2.length() + 1];

        for (int j = 0; j <= str2.length(); j++) {
            dp[j] = j;
        }

        for (int i = 1; i <= str1.length(); i++) {
            System.arraycopy(dp, 0, dp_prev, 0, dp_prev.length);

            dp[0] = i;
            for (int j = 1; j <= str2.length(); j++) {
                int cost = (str1.charAt(i - 1) != str2.charAt(j - 1)) ? 1 : 0;
                dp[j] = min(
                        dp_prev[j] + 1,
                        dp[j - 1] + 1,
                        dp_prev[j - 1] + cost
                );
            }
        }

        return dp[dp.length - 1];
    }

    private static int min(int n1, int n2, int n3) {
        return Math.min(Math.min(n1, n2), n3);
    }
}
